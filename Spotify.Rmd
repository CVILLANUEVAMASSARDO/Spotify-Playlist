---
title: "Spotify - Recomendación de Playlist"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Introducción

### 1.1 Análisis de música
El objetivo de esta tarea es ver cómo abordan un problema de la vida real, con incertidumbre, ya que en el mundo profesional se enfrentarán con tareas similares.

### 1.2 Descripción del problema
Spotify recomienda nuevas canciones a sus usuarios basándose en las reproducciones pasadas y en estilos musicales similares. Esto lo hace a través de diversos algoritmos que relacionan las canciones a través de diferentes atributos como la verbosidad o energía. Una lista con las mediciones que se hace para cada canción esta disponible en la documentación de la API de Spotify(https://developer.spotify.com/documentation/web-api/reference/).

El objetivo principal de este encargo es crear un programa computacional que permita crear una lista de reproducción de 3 horas de duración basándose en alguna canción de referencia. La base de datos incluye 447.622 canciones, con 36 de las variables descritas en la documentación de la API.

Como resultado de la prueba, genere un reporte en RMarkdown describiendo las etapas de su proceso, los modelos de clustering utilizados, los resultados obtenidos y el código empleado. Debe explicar cómo limpió los datos, como se eligieron y generaron las variables, y como construyó su lógica.

### 1.3 Metodología utilizada
Se estudiarán las características de audio de las distintas canciones con el objetivo de realizar análisis de agrupaciones para ofrecer recomendaciones que sean similares a la canción de referencia utilizada. Se intentará comprobar si existe algún patrón para clusterizar y en qué se diferencia cada cluster.


# 2. Paquetes requeridos

```{r, echo = TRUE, message = FALSE}
library(tidyverse)
library(corrplot)
```

### 2.1 Información de paquetes utilizados

**tidyverse** - Permite la manipulación, importación, exploración y visualización de datos. Contiene los paquetes readr, dplyr, ggplot2, tibble, tidyr, purr, stringr y forcats.

**corrplot** - Visualización de correlación entre variables.

# 3. Preparación de los datos

### 3.1 Fuente
Se utilizará el archivo "beats.RData" que contiene 447.622 canciones con 36 variables cada una.

Datos extraídos de la API de Spotify.

```{r}
load('beats.RData')
beats <- beats
```

```{r, echo = FALSE, message = TRUE}
cat("El dataframe contiene", nrow(beats), "filas y", ncol(beats), "columnas.")
```

### 3.2 Información
Nombre de columna, tipo de dato y registro de la columna.

```{r}
glimpse(beats)
```

### 3.2 Limpieza

#### 3.2.1 Removiendo duplicados
Se remueven las canciones duplicadas.

```{r}
beats <- beats[!duplicated(beats$track_id),]
```

#### 3.2.2 Creando variables
Se crea la variable que mide la duración de la canción en minutos.

```{r}
beats$duration_min <- beats$duration_ms / 60000
```

#### 3.2.3 Removiendo variables
Para el análisis que se busca, se necesitan las características de sonido de la canción, su duración y su nombre.

Solo se conservaran estas variables y se removerá el resto.

```{r}
beats <- beats %>% select(c(track_name,duration_min,8:18))
```

#### 3.2.4 Removiendo NA's
Se observa que las variables seleccionadas están limpias y no presentan NA´s.

No es necesario realizar limpieza.

```{r}
colSums(is.na(beats))
```

### 3.3 Descripción de los atributos
Cada canción presente en la base de datos contiene los siguientes atributos:

**track_name** - Nombre de la canción.

**duration_min** - Duración en minutos.

**danceability** - Qué tan bailable es la canción, donde 0,0 es el menor y 1,0 es el mayor.

**energy** - Que tanta intensidad y actividad representa, donde 0,0 es el menor y 1,0 es el mayor.

**key** - Clave de la pista. 0 es Do, 1 es Do#, 2 es Re y así sucesivamente. Cuando no presenta tonalidad es -1.

**loudness** - Qué tanto decibelios (dB) tiene la canción. Oscila entre -60 y 0 dB.

**mode** - Contenido melódico de la canción. Mayor es 1 y Menor es 0.

**speechiness** - Presencia de palabras habladas. 1 es el mayor y 0 es el menor.

**acousticness** - Acústica de la canción. 1 es acústica y 0 es no acústica.

**instrumentalness** - Presencia de voces. 1 es instrumento y 0 es voz.

**liveness** - Detecta público en la grabación. Mayor valor es alta presencia de público.

**valence** - Positividad de la canción. 1 es alegre y 0 es triste.

**tempo** - Pulsaciones por minuto (BPM).

```{r, echo = FALSE, message = TRUE}
cat("El dataframe contiene", nrow(beats), "filas y", ncol(beats), "columnas.")
```

# 4 Análisis exploratorio de datos (EDA)

### 4.1 Mapa de correlación

```{r}
beats_atributos <- select(beats, 3:13)
corrplot(cor(beats_atributos))
```

### 4.2 Histograma

```{r}
beats_grafico <- beats_atributos %>% tidyr::gather(key = "variable", value = "valor")

ggplot(beats_grafico, aes(x = valor, fill = variable)) +
  geom_histogram(binwidth=0.25) +
  facet_wrap(~ variable, scales = "free") +
  scale_fill_hue() +
  guides(fill = "none") +
  theme(legend.position = "none")
```

### 4.3 Boxplot

```{r}
ggplot(beats_grafico, aes(x = variable, y = valor)) +
  geom_boxplot(aes(fill = variable)) +
  facet_wrap(~ variable, scales = "free") +
  scale_fill_hue() +
  guides(fill = "none") +
  theme(legend.position = "none")
```



# 5 Construcción del modelo

### 5.1 Escalar los datos

```{r}
summary(beats_atributos)
```

```{r}
beats_escalar <- scale(beats_atributos)
summary(beats_escalar)
```

### 5.1 Método del codo (Elbow)

```{r}
wss <- function(data, maxCluster = 30) {
  SSw <- (nrow(data) - 1) * sum(apply(data, 2, var))
  SSw <- vector()
  for (i in 2:maxCluster) {
    SSw[i] <- sum(kmeans(data, centers = i)$withinss)
  }
  plot(1:maxCluster, SSw, type = "o", xlab = "Number of Clusters", ylab = "Within groups sum of squares", pch=19)
}

wss(beats_escalar)
```


### 5.2 Clusterización K-means

```{r}
wss <- function(data, maxCluster = 30) {
  SSw <- (nrow(data) - 1) * sum(apply(data, 2, var))
  SSw <- vector()
  for (i in 2:maxCluster) {
    SSw[i] <- sum(kmeans(data, centers = i)$withinss)
  }
  plot(1:maxCluster, SSw, type = "o", xlab = "Number of Clusters", ylab = "Within groups sum of squares", pch=19)
}

wss(beats_escalar)
```